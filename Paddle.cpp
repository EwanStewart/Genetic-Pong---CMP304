#include "Paddle.h"
#include <iostream>

Paddle::Paddle(int c[3], int y_sens, float m)   //params generated by the generation in respect to the last generation
{
    ball_y_sensitivity = y_sens;
    multiplier = m;

    //assign the paddle start y position randomly
    int num = (rand() % 350 + 1 - 20) + 100;
    y_pos = 250 + num;
    x_pos = 20;

    //copy the rgb array
    for (int i = 0; i < 3; i++) {
        colour[i] = c[i];
    }

    //draw the paddle
    draw_paddle();
}

bool Paddle::collide(CircleShape circ)  //if the paddle collides with the ball increment the score count
{
    if (circ.getGlobalBounds().intersects(rect.getGlobalBounds())) {
        score++;
        return true;
    }

    return false;
}

void Paddle::draw_paddle()  //set paddle draw parameters
{
    rect.setFillColor(Color(colour[0], colour[1], colour[2]));
    rect.setSize(sf::Vector2f(width, height));
    rect.setPosition(x_pos, 250);
}

bool Paddle::bounds(float direction)    //check paddle is in bounds of the screen
{
    auto a = rect.getPosition();
    if ( ((rect.getPosition().y + direction) >= 20) && ((rect.getPosition().y + direction) <= 445)) {
        return true;
    }
    return false;
}

void Paddle::move_paddle(CircleShape circ)  //paddle movement, using generated parameters decides how to follow the ball
{
    int balls_y = circ.getPosition().y;                                      //balls current y position
    float intercept_position = (balls_y + ball_y_sensitivity) * multiplier;  //generate position for paddle to collide with ball

    if (rect.getPosition().y != intercept_position) {       //if paddle not in intercept position
        if (rect.getPosition().y < (intercept_position)) {  //if paddle below ball, move up
            if (bounds(speed)) {
                rect.move(0.f, speed);
            }
        }
        else if (rect.getPosition().y > (intercept_position)) { //if paddle above ball, move down
            if (bounds(-speed)) {
                rect.move(0.f, -speed);
            }
        }
    }


}


RectangleShape Paddle::getRect()
{
    return rect;
}

int Paddle::getBallYSensitivity()
{
    return ball_y_sensitivity;
}

float Paddle::getMultiplier()
{
    return multiplier;
}

int Paddle::getScore()
{
    return score;
}
