#include "Paddle.h"

Paddle::Paddle(int c[3], int y_sens, float m)   //params generated by the generation in respect to the last generation
{
    //generated values by genetic algorithm
    ball_y_sensitivity = y_sens;
    multiplier = m;

    //copy the rgb array
    for (int i = 0; i < 3; i++) {
        colour[i] = c[i];
    }

    //draw the paddle
    draw_paddle();
}

bool Paddle::collide(CircleShape circ)  //if the paddle collides with the ball increment the score count
{

    if (circ.getGlobalBounds().intersects(rect.getGlobalBounds())) {
        score++;
        return true;
    }

    return false;
}

void Paddle::draw_paddle()  //set paddle draw parameters
{
    rect.setFillColor(Color(colour[0], colour[1], colour[2]));
    rect.setSize(sf::Vector2f(width, height));
    rect.setOrigin(width/2, height/2);
    rect.setPosition(20, 250);
}



void Paddle::move_paddle(CircleShape circ)  //paddle movement, using generated parameters decides how to follow the ball
{
    int balls_y = circ.getPosition().y;
    int rect_y = rect.getPosition().y + (height / 2);

    int intercept_position = 0.f;

    if (rect.getPosition().y < (balls_y)) {
        intercept_position = (balls_y + ball_y_sensitivity) * multiplier;  //generate position for paddle to collide with ball

    }
    else if (rect.getPosition().y > (balls_y)) {
        intercept_position = (balls_y - ball_y_sensitivity) * multiplier;  //generate position for paddle to collide with ball
    }

    if (circ.getPosition().x < 250) {
        if (rect.getPosition().y != intercept_position) {       //if paddle not in intercept position
            if (rect.getPosition().y < (intercept_position)) {  //if paddle below ball, move up
                rect.move(0.f, speed);
            }
            else if (rect.getPosition().y > (intercept_position)) { //if paddle above ball, move down
                rect.move(0.f, -speed);
            }
        }
    }
    else {
        if (rect.getPosition().y < (250)) {  //if paddle below ball, move up
            rect.move(0.f, speed);
        }
        else if (rect.getPosition().y > (250)) { //if paddle above ball, move down
            rect.move(0.f, -speed);
        }
    }
}

float Paddle::getSpeed() {
    return speed;
}

RectangleShape Paddle::getRect()
{
    return rect;
}

int Paddle::getBallYSensitivity()
{
    return ball_y_sensitivity;
}

float Paddle::getMultiplier()
{
    return multiplier;
}

int Paddle::getScore()
{
    return score;
}
