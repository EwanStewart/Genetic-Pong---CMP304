#include "Paddle.h"
#include <iostream>

Paddle::Paddle(int c[3], int y_sens, float m)   //params generated by the generation in respect to the last generation
{
    ball_y_sensitivity = y_sens;
    multiplier = m;

    //assign the paddle start y position randomly
    int num = (rand() % 250 - 100);
    y_pos = 250 + num;
    x_pos = 20;

    //copy the rgb array
    for (int i = 0; i < 3; i++) {
        colour[i] = c[i];
    }

    //draw the paddle
    draw_paddle();
}

bool Paddle::collide(CircleShape circ)  //if the paddle collides with the ball increment the score count
{
    /*
    if (circ.getPosition().x <= rect.getPosition().x + rect.getSize().x) {
        if (circ.getPosition().y >= rect.getPosition().y && circ.getPosition().y <= rect.getPosition().y + rect.getSize().y) {
            score++;
            return true;
        }
    }
    */
    if (circ.getGlobalBounds().intersects(rect.getGlobalBounds())) {
        score++;
        return true;
    }



    return false;
}

void Paddle::draw_paddle()  //set paddle draw parameters
{
    rect.setFillColor(Color(colour[0], colour[1], colour[2]));
    rect.setSize(sf::Vector2f(width, height));
    rect.setOrigin(width/2, height/2);
    rect.setPosition(x_pos, y_pos);
}



void Paddle::move_paddle(CircleShape circ)  //paddle movement, using generated parameters decides how to follow the ball
{
    int balls_y = circ.getPosition().y;
    int rect_y = rect.getPosition().y + (height / 2);

    int intercept_position = 0.f;

    if (rect.getPosition().y < (balls_y)) {
        intercept_position = (balls_y + ball_y_sensitivity) * multiplier;  //generate position for paddle to collide with ball

    }
    else if (rect.getPosition().y > (balls_y)) {
        intercept_position = (balls_y - ball_y_sensitivity) * multiplier;  //generate position for paddle to collide with ball
    }





    //intercept_position = balls_y;


    if (circ.getPosition().x < 250) {
        if (rect.getPosition().y != intercept_position) {       //if paddle not in intercept position
            if (rect.getPosition().y < (intercept_position)) {  //if paddle below ball, move up
                rect.move(0.f, speed);
            }
            else if (rect.getPosition().y > (intercept_position)) { //if paddle above ball, move down
                rect.move(0.f, -speed);
            }
        }
    }
    else {
        if (rect.getPosition().y < (250)) {  //if paddle below ball, move up
            rect.move(0.f, speed);
        }
        else if (rect.getPosition().y > (250)) { //if paddle above ball, move down
            rect.move(0.f, -speed);
        }
    }




}


RectangleShape Paddle::getRect()
{
    return rect;
}

int Paddle::getBallYSensitivity()
{
    return ball_y_sensitivity;
}

float Paddle::getMultiplier()
{
    return multiplier;
}

int Paddle::getScore()
{
    return score;
}
